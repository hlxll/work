<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
	<!-- <script src="http://iapi.websaas.cn/cloud-waf/api/common/getChinaLocations"></script> -->
	<input type="button" id="export" value="保存"/>
    <script>
        //全排列
        function permutate(str) {
            //split字符串转数组
            var array = str.split('');
            function loop(array, pre = []) {
                if (array.length == 1) {
                    //concat数组拼接，join数组转字符串
                    return [pre.concat(array).join('')];
                }
                let res = [];
                for (let index = 0; index < array.length; index++) {
                    //pop删除数组最后一个并返回最后一个
                    var first = array.pop();
                    res = res.concat(loop(array, [...pre, first]));
                    //向数组开头添加元素，返回新长度
                    array.unshift(first);
                }
                return res;
            }
            return Array.from(new Set(loop(array)))
        }
        var str = '123'
        console.log(permutate(str))

        function BubbleStr(arr){
            const length = arr.length
            for(var i=0;i<length-1;i++){
                for(var j=0;j<length - i;j++){
                    arr[j+1]>arr[j]
                    const temp = arr[j]
                    arr[j] = arr[j+1]
                    arr[j+1]=temp
                }
            }
            return arr;
        }

        function InsertionSort (arr) {
            //规定前面是排好序的，取没有排好序的最左边一个，提前保存在常量，和排好序的从右往左比较，将符合排序要求的数往右赋值
            //，然后j一直减一，最后不符合排序要求之后，j+1就是没有往右赋值，这个位置就是原先保存的常量插入的位置
            const length = arr.length
            for (let i = 1; i < length; i++) {
                const temp = arr[i]//2
                let j
                for (j = i - 1; j >= 0 && temp < arr[j]; j--) {
                    arr[j+1] = arr[j]
                }
                console.log(j+1)
                arr[j+1] = temp
            }
            return arr
        }
        var data = [1,2,4,3,6,5]
        console.log(InsertionSort(data))
        function IsURL(str_url){
            var strRegex = "^(ht|f)tp(s?)\:\/\/[a-zA-Z0-9\-\._]+(\.[a-zA-Z0-9\-\._]+){2,}(\/?)([a-zA-Z0-9\-\.\?\,\'\/\\\+&amp;%\$#_]*)?$"
            var re=new RegExp(strRegex);
            if (re.test(str_url)){
            return (true);
            }else{
            alert("请输入正确的公司主页地址!")
            return (false);
            }
        }
        IsURL('http://www.sbsb.com:80')
        function yuname(str){
            var strRegex =  "^(?=^.{3,255}$)[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$"
            var re = new RegExp(strRegex)
            if(re.test(str)){
                return (true)
            }else{
                alert("域名不正确")
                return false
            }
        }
        yuname('www.sbsb')

        function saveHandler(){
            let data = {
                name:"hanmeimei",
                age:88
            }
            var content = JSON.stringify(data);
            var blob = new Blob([content], {type: "text/plain;charset=utf-8"});
            saveAs(blob, "save.json");
        }

        var button = document.getElementById('export')
        button.addEventListener('click', prototypeSearch, false)
        function prototypeSearch(){
            function handleSome(){
                this.bar = '1'
            }
            handleSome.prototype = { bar : 'oneVersion'}
            var twoFun = new handleSome()
            //new一个函数，函数内部的 this 属性也属于这个函数，
            //hasOwnProperty检查对象是否有属于自己的属性，不会遍历原型链。
            twoFun.data = 'twoVersion'
            // console.log(twoFun.hasOwnProperty('bar')) //true,是找到了handleSome的this.bar
            var proto = {
                bar_prop: 'bar val'
            }
            // setPrototypeOf ,为对象添加__proto__
            Object.setPrototypeOf(
                proto, handleSome.prototype
            )
            function newFun(){}
            newFun.prototype = proto
            var newBar = new newFun()

            // getPrototype是用于实例的，prototype是用于类的，功能一样
            //console.log(Object.getPrototypeOf(newBar))
            
            // new一个函数，相当于
            // var o = new Foo()
            //var o = new Object()
            // o.__proto__ = Foo.prototype;
            // Foo.call(o)

            function add(){
                var sum = 0;
                for(let i=0;i<arguments.length;i++){
                    sum += arguments[i]
                }
                return sum
            }
            //一个函数的参数，实际上是调用函数内部默认的 arguments，就算函数定义时候没有参数，使用时候也可以加参数
            //console.log(add(1,2,3,4))

            var o = { a:0 }
            //为对象添加属性
            Object.defineProperty(o, "b", {get: function() { return this.a + 1 }})
            //delete o.a 直接删除对象的属性
            console.log(o)
        }

        
        
    </script>
</body>
</html>