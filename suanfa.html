<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
	<!-- <script src="http://iapi.websaas.cn/cloud-waf/api/common/getChinaLocations"></script> -->
	<input type="button" id="export" value="保存"/>
    <script>
        //全排列
        function permutate(str) {
            //split字符串转数组
            var array = str.split('');
            function loop(array, pre = []) {
                if (array.length == 1) {
                    //concat数组拼接，join数组转字符串
                    return [pre.concat(array).join('')];
                }
                let res = [];
                for (let index = 0; index < array.length; index++) {
                    //pop删除数组最后一个并返回最后一个
                    var first = array.pop();
                    res = res.concat(loop(array, [...pre, first]));
                    //向数组开头添加元素，返回新长度
                    array.unshift(first);
                }
                return res;
            }
            return Array.from(new Set(loop(array)))
        }
        var str = '123'
        console.log(permutate(str))

        function BubbleStr(arr){
            const length = arr.length
            for(var i=0;i<length-1;i++){
                for(var j=0;j<length - i;j++){
                    arr[j+1]>arr[j]
                    const temp = arr[j]
                    arr[j] = arr[j+1]
                    arr[j+1]=temp
                }
            }
            return arr;
        }

        function InsertionSort (arr) {
            //规定前面是排好序的，取没有排好序的最左边一个，提前保存在常量，和排好序的从右往左比较，将符合排序要求的数往右赋值
            //，然后j一直减一，最后不符合排序要求之后，j+1就是没有往右赋值，这个位置就是原先保存的常量插入的位置
            const length = arr.length
            for (let i = 1; i < length; i++) {
                const temp = arr[i]//2
                let j
                for (j = i - 1; j >= 0 && temp < arr[j]; j--) {
                    arr[j+1] = arr[j]
                }
                console.log(j+1)
                arr[j+1] = temp
            }
            return arr
        }
        var data = [1,2,4,3,6,5]
        console.log(InsertionSort(data))
        function IsURL(str_url){
            var strRegex = "^(ht|f)tp(s?)\:\/\/[a-zA-Z0-9\-\._]+(\.[a-zA-Z0-9\-\._]+){2,}(\/?)([a-zA-Z0-9\-\.\?\,\'\/\\\+&amp;%\$#_]*)?$"
            var re=new RegExp(strRegex);
            if (re.test(str_url)){
            return (true);
            }else{
            alert("请输入正确的公司主页地址!")
            return (false);
            }
        }
        IsURL('http://www.sbsb.com:80')
        function yuname(str){
            var strRegex =  "^(?=^.{3,255}$)[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$"
            var re = new RegExp(strRegex)
            if(re.test(str)){
                return (true)
            }else{
                alert("域名不正确")
                return false
            }
        }
        yuname('www.sbsb')

        function saveHandler(){
            let data = {
                name:"hanmeimei",
                age:88
            }
            var content = JSON.stringify(data);
            var blob = new Blob([content], {type: "text/plain;charset=utf-8"});
            saveAs(blob, "save.json");
        }

        var button = document.getElementById('export')
        button.addEventListener('click', prototypeSearch, false)
        function prototypeSearch(){
            function handleSome(){
                this.bar = '1'
            }
            handleSome.prototype = { bar : 'oneVersion'}
            var twoFun = new handleSome()
            //new一个函数，函数内部的 this 属性也属于这个函数，
            //hasOwnProperty检查对象是否有属于自己的属性，不会遍历原型链。
            twoFun.data = 'twoVersion'
            // console.log(twoFun.hasOwnProperty('bar')) //true,是找到了handleSome的this.bar
            var proto = {
                bar_prop: 'bar val'
            }
            // setPrototypeOf ,为对象添加__proto__
            Object.setPrototypeOf(
                proto, handleSome.prototype
            )
            function newFun(){}
            newFun.prototype = proto
            var newBar = new newFun()

            // getPrototype是用于实例的，prototype是用于类的，功能一样
            //console.log(Object.getPrototypeOf(newBar))
            
            // new一个函数，相当于
            // var o = new Foo()
            //var o = new Object()
            // o.__proto__ = Foo.prototype;
            // Foo.call(o)

            function add(){
                var sum = 0;
                for(let i=0;i<arguments.length;i++){
                    sum += arguments[i]
                }
                return sum
            }
            //一个函数的参数，实际上是调用函数内部默认的 arguments，就算函数定义时候没有参数，使用时候也可以加参数
            //console.log(add(1,2,3,4))

            var o = { a:0 }
            //为对象添加属性
            Object.defineProperty(o, "b", {get: function() { return this.a + 1 }})
            //delete o.a 直接删除对象的属性
            console.log(o)
        }

        //利用递归，将四个数字实现加减乘除任意排序方法，使得数字等于24的验证
        function judePoint24(nums) {
            if(nums.length == 1){
                const cha = nums[0] - 24;
                return Math.abs(cha) < 0.00001;
            }
            for(let i=0;i<nums.length;i++){
                for(let j=i+1;j<nums.length;j++){
                    let dataArr = nums.slice();
                    dataArr.splice(j, 1)
                    dataArr.splice(i, 1)
                    let aData = nums[i];
                    let bData = nums[j];
                    var retureData = false;
                    retureData = retureData || judePoint24(dataArr.concat(aData + bData));
                    retureData = retureData || judePoint24(dataArr.concat(aData - bData));
                    retureData = retureData || judePoint24(dataArr.concat(bData - aData));
                    retureData = retureData || judePoint24(dataArr.concat(aData * bData));
                    if(bData != 0){
                        retureData = retureData || judePoint24(dataArr.concat(aData / bData));
                    }
                    if(aData != 0){
                        retureData = retureData || judePoint24(dataArr.concat(bData / aData));
                    }
                    if(retureData) return true;
                }
            }
            return false;
        }
        // console.log(judePoint24([6,6,6,6]))
        let arrLength = 0;
        function lengthofSunstring(s, leftArr = 0) {
            let arrS = s.split(' ')
            let arrData = [];
            
            for(let i=leftArr;i<arrS.length;i++){
                let pushTure = true;
                for(let j=0;j<arrData.length;j++){
                    if(arrS[i] == arrData[j]){
                        pushTure = false;
                    }
                }
                if(pushTure){
                    arrData.push(arrS[i])
                }else{
                    arrLength = arrData.length>arrLength?arrData.length:arrLength;
                    lengthofSunstring(s, arrLength)
                }
            }
            console.log(arrLength)
        }
        lengthofSunstring('asdasdxczcas')

//输入: "abcabcbb"
// 输出: 3 
// 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
        var lengthOfLongestSubstring = function(d) {
            let s = d.split('')
            let TopNum = 0;
            for(let i=0;i<s.length;i++){
                let data = s.splice(0, i+1)
                var arrData = [];
                arrData.push(s[i])
                function addNum(data){
                    let bloom = false;
                    arrData.forEach(item=> {
                        if(item = data[0]){
                            bloom = true;
                        }
                    })
                    if(!bloom){
                        arrData.push(data[0])
                        let childData = data.splice(0, 1)
                        return addNum(childData);
                    }
                }
                addNum(data)
                TopNum = (arrData.length>TopNum)?arrData.length:TopNum;
            }
            return TopNum;
        };

        //牛客算法
        // 输入一行，两个数字
        while(line=readline()){
            var lines = line.split(' ');
            var a = parseInt(lines[0]);
            var b = parseInt(lines[1]);
            print(a+b);
        }
        //输入多行
        // 输入
        // 2 
        // 1 2
        // 3 4
        // 输出两行
        var a =parseInt(readline());
        if(a>0){
            for(var i=0;i<a;i++){
                var lines=readline();
                var line=lines.split(' ');
                var b=parseInt(line[0]);
                var c=parseInt(line[1]);
            console.log(b+c);
            } 
        }
        //输入多行数据，每行两个，计算结果
        var input = []
        while(line = readline()) {
            if(line == '0 0') {
                break;
            } else {
                input.push(line);
            }
        }
        
        var resultArr = [];
        
        for(let i = 0; i < input.length; i++) {
            var tempArr = input[i].split(' ');
            var res = parseInt(tempArr[0]) + parseInt(tempArr[1]);
            resultArr.push(res);
        }
        
        for(let i = 0; i < resultArr.length; i++) {
            print(resultArr[i]);
        }

        //第一行数字显示后面有几行，后面每行第一个，显示后面有几个数，求后面数的和
        let num = parseInt(readline())
        for(let i=0; i<num; i++){
            let arr = readline().split(' ')
            let first = parseInt(arr.shift())
            let newArr = arr.map(item=>parseInt(item))
            print(newArr.reduce((a,b)=>a+b))
        }




    </script>
</body>
</html>